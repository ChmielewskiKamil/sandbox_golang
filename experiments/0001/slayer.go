package main

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"sync"
	"time"
)

const (
	// Path to a mutant directory generated by Certora's Gambit.
	mutantsDir = "./gambit_out/mutants"
	// Absolute path from the root of the project to the original, unmutated file.
	originalFilePath = "src/Tempo.sol"
	// To simplify the code, we also care about the original file name (without depending on the path).
	originalFileName = "Tempo.sol"
	// Absolute path from the root of the project to where you want to store the backup file.
	backupFile = "src/Backup.sol"
	// Adjust this according to your CPU and system resources
	maxConcurrency = 2
)

func main() {
	copyFile(originalFilePath, backupFile)

	mutants, err := os.ReadDir(mutantsDir)
	if err != nil {
		fmt.Println("Error reading directory:", err)
		return
	}

	var wg sync.WaitGroup

	// Create a buffered channel to control the number of concurrent Goroutines
	limiter := make(chan struct{}, maxConcurrency)

	for _, m := range mutants {
		wg.Add(1)
		limiter <- struct{}{} // Acquire token from the limiter channel
		go func(m os.DirEntry) {
			defer func() {
				<-limiter // Release token back to limiter channel
				wg.Done() // Decrement WaitGroup counter when Goroutine finishes
			}()
			fmt.Printf("Trying to slay mutant %s\n", m.Name())
			applyMutation(m)
			slain := slayMutant()
			if slain {
				fmt.Printf("Mutant %s is slain\n", m.Name())
				removeMutantDir(m)
			} else {
				fmt.Printf("Mutant %s is not slain\n", m.Name())
			}
		}(m)
		time.Sleep(1 * time.Second)
	}

	wg.Wait()
	cleanUp()
}

func removeMutantDir(m os.DirEntry) {
	err := os.RemoveAll(filepath.Join(mutantsDir, m.Name()))
	if err != nil {
		fmt.Println("Error removing mutant directory:", err)
		return
	}
}

func applyMutation(m os.DirEntry) {
	mutatedFilePath := filepath.Join(mutantsDir, m.Name(), "src", originalFileName)
	copyFile(mutatedFilePath, originalFilePath)
}

// slayMutant runs the test suite and returns true if the mutant is slain. Otherwise,
// if the test suite passes while the code is mutated, the mutant is not slain.
func slayMutant() (slain bool) {
	// The --fail-fast flag will stop the test suite execution as soon as a test fails.
	cmd := exec.Command("forge", "test", "--fail-fast")
	err := cmd.Run()
	if err != nil {
		_, ok := err.(*exec.ExitError)
		if !ok {
			panic(err)
		}
		// The test suite failed, the mutant is slain.
		return true
	}

	// If the test suite passes, while the code is mutated, the mutant is not slain.
	// We have a blind spot in the test suite.
	return false
}

// copyFile copies the content of the source file to the destination file. The src and dest
// are file paths e.g. src: "src/Counter.sol" and dest: "src/CounterCopy.sol".
func copyFile(src, dest string) {
	srcContent, err := os.ReadFile(src)
	if err != nil {
		fmt.Println("Error reading file:", err)
		return
	}

	err = os.WriteFile(dest, srcContent, 0644)
	if err != nil {
		fmt.Println("Error writing file:", err)
		return
	}
}

// cleanUp restores the original file and removes the backup file.
func cleanUp() {
	copyFile(backupFile, originalFilePath)
	err := os.Remove(backupFile)
	if err != nil {
		fmt.Println("Error removing backup file:", err)
		return
	}
}
