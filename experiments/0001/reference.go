// package main
//
// import (
// 	"fmt"
// 	"os"
// 	"os/exec"
// 	"path/filepath"
// 	"strconv"
// 	"time"
// )
//
// const (
// 	// Path to a mutant directory generated by Certora's Gambit.
// 	mutantsDir = "./gambit_out/mutants"
// 	// Absolute path from the root of the project to the original, unmutated file.
// 	originalFilePath = "src/Counter.sol"
// 	// To simplify the code, we also care about the original file name (without depending on the path).
// 	originalFileName = "Counter.sol"
// 	// Absolute path from the root of the project to where you want to store the backup file.
// 	backupFile = "src/Backup.sol"
// )
//
// func main() {
// 	startTime := time.Now()
// 	Old()
// 	fmt.Printf("Execution time: %v\n", time.Since(startTime))
// }
//
// // Before running the script, make sure to generate mutants using Certora's Gambit.
// // e.g. gambit mutate --filename src/Savings.sol --contract Savings
// func Old() {
// 	// Create a backup of the original file, so that we can restore it after slaying the mutants.
// 	copyFile(originalFilePath, backupFile)
//
// 	mutants, err := os.ReadDir(mutantsDir)
// 	if err != nil {
// 		fmt.Println("Error reading directory:", err)
// 		return
// 	}
//
// 	totalMutants := len(mutants)
// 	fmt.Printf("Found: %d mutants\n", totalMutants)
// 	slainMutants := 0
//
// 	for _, m := range mutants {
// 		mutantNumber, err := strconv.Atoi(m.Name())
// 		if err != nil {
// 			fmt.Println("Error converting mutant directory number to integer:", err)
// 			return
// 		}
//
// 		mutatedFilePath := filepath.Join(mutantsDir, m.Name(), "src", originalFileName)
// 		copyFile(mutatedFilePath, originalFilePath)
// 		slain := slayMutant()
// 		if slain {
// 			fmt.Printf("Mutant %d is slain\n", mutantNumber)
// 			slainMutants++
// 			fmt.Printf("Remaining mutants: %d\n", totalMutants-slainMutants)
// 			// Remove mutant directory, if our test suite slays the mutant.
// 			err := os.RemoveAll(filepath.Join(mutantsDir, m.Name()))
// 			if err != nil {
// 				fmt.Println("Error removing mutant directory:", err)
// 				return
// 			}
// 		} else {
// 			fmt.Printf("Mutant %d is not slain\n", mutantNumber)
// 		}
// 	}
//
// 	fmt.Printf("Total mutants: %d, Slain mutants: %d\n", totalMutants, slainMutants)
//
// 	cleanUp()
// }
//
// // slayMutant runs the test suite and returns true if the mutant is slain. Otherwise,
// // if the test suite passes while the code is mutated, the mutant is not slain.
// func slayMutant() (slain bool) {
// 	// The --fail-fast flag will stop the test suite execution as soon as a test fails.
// 	cmd := exec.Command("forge", "test", "--fail-fast")
// 	err := cmd.Run()
// 	if err != nil {
// 		_, ok := err.(*exec.ExitError)
// 		if !ok {
// 			panic(err)
// 		}
// 		// The test suite failed, the mutant is slain.
// 		return true
// 	}
//
// 	// If the test suite passes, while the code is mutated, the mutant is not slain.
// 	// We have a blind spot in the test suite.
// 	return false
// }
//
// // copyFile copies the content of the source file to the destination file. The src and dest
// // are file paths e.g. src: "src/Counter.sol" and dest: "src/CounterCopy.sol".
// func copyFile(src, dest string) {
// 	srcContent, err := os.ReadFile(src)
// 	if err != nil {
// 		fmt.Println("Error reading file:", err)
// 		return
// 	}
//
// 	err = os.WriteFile(dest, srcContent, 0644)
// 	if err != nil {
// 		fmt.Println("Error writing file:", err)
// 		return
// 	}
// }
//
// // cleanUp restores the original file and removes the backup file.
// func cleanUp() {
// 	copyFile(backupFile, originalFilePath)
// 	err := os.Remove(backupFile)
// 	if err != nil {
// 		fmt.Println("Error removing backup file:", err)
// 		return
// 	}
// }
